@page "/auth/google/callback"
@inject IJSRuntime JS
@inject CompanioNationSignalRClient SignalRClient
@inject NavigationManager Nav

<h3>Signing you in…</h3>
@if (!string.IsNullOrEmpty(_error))
{
    <div class="error-message">@_error</div>
    @if (_showAlternateLogin)
    {
        <div class="alternate-login">
            <p>If Google keeps failing, continue with the standard CompanioNation™ login instead.</p>
            <button type="button" class="blueButton" @onclick="UseAlternateLogin">
                Try email or password login
            </button>
        </div>
    }
}

@code {
    private string _error;
    private bool _showAlternateLogin;

    private static string GetQueryParam(Uri uri, string key)
    {
        if (uri == null) return null;
        var query = uri.Query;
        if (string.IsNullOrEmpty(query)) return null;

        foreach (var part in query.TrimStart('?').Split('&', StringSplitOptions.RemoveEmptyEntries))
        {
            var kv = part.Split('=', 2);
            if (kv.Length == 2 && string.Equals(Uri.UnescapeDataString(kv[0]), key, StringComparison.OrdinalIgnoreCase))
            {
                return Uri.UnescapeDataString(kv[1]);
            }
        }
        return null;
    }

    private static string GetFragmentParam(Uri uri, string key)
    {
        if (uri == null) return null;
        var frag = uri.Fragment;
        if (string.IsNullOrEmpty(frag)) return null;

        foreach (var part in frag.TrimStart('#').Split('&', StringSplitOptions.RemoveEmptyEntries))
        {
            var kv = part.Split('=', 2);
            if (kv.Length == 2 && string.Equals(Uri.UnescapeDataString(kv[0]), key, StringComparison.OrdinalIgnoreCase))
            {
                return Uri.UnescapeDataString(kv[1]);
            }
        }
        return null;
    }

    private static byte[] Base64UrlDecode(string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return Array.Empty<byte>();
        string s = input.Replace('-', '+').Replace('_', '/');
        switch (s.Length % 4)
        {
            case 2: s += "=="; break;
            case 3: s += "="; break;
        }
        return Convert.FromBase64String(s);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        var uri = Nav.ToAbsoluteUri(Nav.Uri);

        // Extract parameters
        var authCode = GetQueryParam(uri, "code");
        string codeVerifier = null;
        var redirectUri = Nav.BaseUri.TrimEnd('/') + "/auth/google/callback";
        var state = GetQueryParam(uri, "state"); // must match what we sent

        // Validate state if present
        bool stateValid = true;
        try
        {
            var expectedState = await JS.InvokeAsync<string>("sessionStorage.getItem", "google_oauth_state");
            await JS.InvokeVoidAsync("sessionStorage.removeItem", "google_oauth_state");
            await JS.InvokeVoidAsync("sessionStorage.removeItem", "google_oauth_state_ts");
            // keep returnUrl optional; remove after use
            await JS.InvokeVoidAsync("sessionStorage.removeItem", "google_oauth_returnUrl");

            stateValid = !string.IsNullOrEmpty(expectedState) && string.Equals(state, expectedState, StringComparison.Ordinal);
        }
        catch
        {
            // If we cannot read storage and state is present in URL, treat as invalid
            stateValid = false;
        }

        if (!stateValid)
        {
            // scrub any leftover verifier on mismatch
            try { await JS.InvokeVoidAsync("sessionStorage.removeItem", "google_oauth_code_verifier"); } catch { }

            ShowOAuthError("Invalid login state. Please try again or use a different login option.");
            try { await SignalRClient.LogError("Google OAuth state mismatch; possible CSRF."); } catch { }
            StateHasChanged();
            return;
        }

        // Retrieve PKCE verifier
        try
        {
            codeVerifier = await JS.InvokeAsync<string>("sessionStorage.getItem", "google_oauth_code_verifier");
            await JS.InvokeVoidAsync("sessionStorage.removeItem", "google_oauth_code_verifier");
        }
        catch
        {
            codeVerifier = null;
        }

        // Clean sensitive params from the address bar
        try
        {
            await JS.InvokeVoidAsync("eval", "history.replaceState(null,'', location.origin + location.pathname);");
        }
        catch { }

        if (!string.IsNullOrWhiteSpace(authCode) && !string.IsNullOrWhiteSpace(codeVerifier))
        {
            try
            {
                var result = await SignalRClient.LoginWithGoogle(authCode, codeVerifier, redirectUri);
                if (result.IsSuccess)
                {
                    Nav.NavigateTo("/", true);
                    return;
                }

                ShowOAuthError(result.Message ?? "Google sign-in failed. Please retry or pick another login option.");
                StateHasChanged();
                try { await SignalRClient.LogError($"Google login failed: {result.ErrorCode}: {result.Message}"); } catch { }
                return;
            }
            catch (Exception ex)
            {
                await SignalRClient.LogError(ex, "Google OAuth exchange unexpectedly failed.");
                ShowOAuthError("We couldn't finish signing you in with Google. Please try again or use a different login option.");
                StateHasChanged();
                return;
            }
        }
        else if (!string.IsNullOrWhiteSpace(authCode))
        {
            try { await SignalRClient.LogError($"Google callback received code (state={state ?? ""}) but missing code_verifier."); } catch { }
            ShowOAuthError("Google returned an incomplete response. Please retry or use another login option.");
            StateHasChanged();
            return;
        }

        // Fallback: go home
        Nav.NavigateTo("/");
    }

    private void ShowOAuthError(string message)
    {
        _error = message;
        _showAlternateLogin = true;
    }

    private async Task UseAlternateLogin()
    {
        try
        {
            await SignalRClient.RequestLogin();
        }
        catch
        {
            // Even if the push unregister fails, still route the user back home.
        }

        Nav.NavigateTo("/", false);
    }
}
